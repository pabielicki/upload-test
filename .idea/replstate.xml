<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1462442415531">{:repl-history {:ide [], :local [&quot;(ns upload-test.core\n  (:gen-class)\n  (:use\n   upload-test.sftp-upload)\n  (:require\n    [clojure.java.io :as io]\n    [again.core :as again]\n    [upload-test.retries :refer :all]\n    [clojure.tools.cli :refer [cli]])\n  (:import org.apache.commons.io.input.BoundedInputStream))\n\n\n(def required-opts #{:host :port :file :destination :username :rsa-path})\n\n(defn missing-required?\n  \&quot;Returns true if opts is missing any of the required-opts\&quot;\n  [opts]\n  (not-every? opts required-opts))\n\n(defn file-size [filename]\n  (.length (io/file filename)))\n\n(defn check-progress\n  [f]\n  (let [up-progress (atom 0)]\n    (loop [retries 0]\n      (if-let [xxx (try [(f)]\n                          (catch Exception e\n                            (if (get-in (ex-data e) [:done])\n                              (if (&lt; 0 (- (get-in (ex-data e) [:progress]) @up-progress))\n                                (reset! up-progress (get-in (ex-data e) [:progress]))\n                                (throw e)))))]\n        ;(recur (inc retries))\n        (prn xxx)\n        (do (prn \&quot;Retry\&quot;) (recur retries))))))\n\n(defn upload-async\n  [host port input name destination username rsa-path]\n  (future\n    (check-progress #(again/with-retries [100 100 100] (upload-to-sftp host port input name destination username rsa-path)))))\n\n(defn rounded-single-chunk-size\n  [file count]\n  (int (Math/ceil (/ (file-size file) count))))\n\n(defn chunks-list\n  [name start size]\n  {:name (apply str name \&quot;.part\&quot; (str start)) :start (* start size) :size size})\n\n(defn just-chunk\n  [file count]\n  (let [size (rounded-single-chunk-size file count)]\n    (map #(chunks-list file % size) (range count))))\n\n(defn chunk-and-send-file\n  [file count host port destination username rsa-path]\n  (-&gt;&gt;\n    (just-chunk file count)\n    (map\n      #(let [input (io/input-stream file)]\n        (.skip input (get-in % [:start]))\n        (let [bounded (BoundedInputStream. input (get-in % [:size]))]\n          (upload-async host port bounded (get-in % [:name]) destination username rsa-path))))\n    (map deref)\n    (doall)))\n\n(defn chunked_or_standard_upload [opts]\n  (if (:chunks opts)\n    (time\n      (chunk-and-send-file (:file opts) (Integer. (:chunks opts)) (:host opts) (Integer. (:port opts))\n                           (:destination opts) (:username opts) (:rsa-path opts)))\n    (time\n      (check-progress\n        #(again/with-retries\n         [100 100 100]\n         (upload-to-sftp\n           (:host opts) (Integer. (:port opts)) (:file opts)\n           (if (:name opts) (:name opts) (:file opts))\n           (:destination opts) (:username opts) (:rsa-path opts))))\n      )))\n\n(defn -main [&amp; args]\n  (let [[opts args banner] (cli args\n                                [\&quot;-h\&quot; \&quot;--help\&quot; \&quot;Print this help\&quot;\n                                 :default false :flag true]\n                                [\&quot;-c\&quot; \&quot;--chunks\&quot;]\n                                [\&quot;-f\&quot; \&quot;--file\&quot;]\n                                [\&quot;-n\&quot; \&quot;--name\&quot;]\n                                [\&quot;-d\&quot; \&quot;--destination\&quot;]\n                                [\&quot;-u\&quot; \&quot;--username\&quot;]\n                                [\&quot;-ip\&quot; \&quot;--host\&quot;]\n                                [\&quot;-p\&quot; \&quot;--port\&quot;]\n                                [\&quot;-rsa\&quot; \&quot;--rsa-path\&quot;])]\n    (if (or (:help opts)\n              (missing-required? opts))\n      (println banner)\n      (chunked_or_standard_upload opts)\n      )))\n\n\n(comment\n\n  (upload-async \&quot;192.168.1.105\&quot; 22 \&quot;x.txt\&quot; \&quot;lallaa\&quot; \&quot;Pulpit/takietam/tests\&quot; \&quot;kisiel\&quot; \&quot;/home/paveu/.ssh/id_rsa.test\&quot;)\n  (time (chunk-and-send-file \&quot;x.txt\&quot; 5 \&quot;192.168.1.105\&quot; 22 \&quot;Pulpit/takietam/tests\&quot; \&quot;kisiel\&quot; \&quot;/home/paveu/.ssh/id_rsa.test\&quot;))\n  (time (x \&quot;x.txt\&quot; 5 \&quot;192.168.1.105\&quot; 22 \&quot;Pulpit/takietam/tests\&quot; \&quot;kisiel\&quot; \&quot;/home/paveu/.ssh/id_rsa.test\&quot;))\n  (-main \&quot;-ip\&quot; \&quot;192.168.1.105\&quot; \&quot;-p\&quot; 22 \&quot;-f\&quot; \&quot;x.txt\&quot; \&quot;-d\&quot; \&quot;Pulpit/takietam/tests\&quot; \&quot;-u\&quot; \&quot;kisiel\&quot; \&quot;-rsa\&quot; \&quot;/home/paveu/.ssh/id_rsa.test\&quot;)\n  )&quot; &quot;(ns upload-test.sftp-upload\n  (:use\n    clj-ssh.ssh\n    )\n  (:require\n    [clojure.java.io :as io]\n    [upload-test.retries :refer :all]))\n\n(defmacro my-with-connection\n  \&quot;Creates a context in which the session is connected. Ensures the session is\n  disconnected on exit.\&quot;\n  [session timeout &amp; body]\n  `(let [session# ~session timeout# ~timeout]\n     (try\n       (when-not (connected? session#)\n         (connect session# timeout#))\n       ~@body\n       (finally\n         (disconnect session#)))))\n\n(defn percentage [progress total]\n  (apply str (format \&quot;%.2f\&quot; (float(* 100 (/ progress total)))) \&quot;%\&quot;))\n\n(defn sftp-monitor\n  \&quot;Create a SFTP progress monitor\&quot;\n  []\n  (let [operation (atom nil)\n        source (atom nil)\n        destination (atom nil)\n        size (atom nil)\n        done (atom false)\n        progress (atom 0)\n        continue (atom true)]\n    [ (proxy [com.jcraft.jsch.SftpProgressMonitor] []\n        (init [op src dest max]\n          (do\n            (println (apply str \&quot;Source: \&quot; src \&quot; Destination: \&quot; dest))\n            (reset! operation op)\n            (reset! source src)\n            (reset! destination dest)\n            (reset! size max)\n            (reset! done false)))\n        (count [n]\n          (prn (if (&gt; @size 0)\n                 (percentage @progress @size)\n                 @progress))\n          (swap! progress (partial + n))\n          @continue)\n        (end []\n          (if (&gt; @size 0) (prn \&quot;100,00%\&quot;))\n          (println \&quot;Done\&quot;)\n          (reset! done true)))\n     [operation source destination size done progress continue]]))\n\n\n(defn new-identity\n  [agent rsa-path]\n  (add-identity agent\n                {:private-key-path rsa-path}))\n\n(defn new-session\n  [agent ip username port]\n  (session agent ip\n           {:strict-host-key-checking :no :username username :port port}))\n\n(defn state-wrap\n  [state]\n  (let [[operation source destination size done progress continue] state]\n    {:done true :progress 1 }))\n\n(defn sftp-put\n  [channel input name]\n  (let [[monitor state] (sftp-monitor)]\n    (try\n      ;(sftp channel {:mode :resume :with-monitor monitor}\n      ;     :put input name)\n      (throw (Exception. \&quot;eueue\&quot;))\n      (catch Exception e\n        (throw (ex-info (.getMessage e) (state-wrap state)))))\n    (state-wrap state)))\n\n(defn upload-to-sftp\n  [host port input name destination username rsa-path]\n  (println \&quot;Starting...\&quot;)\n  (let [agent (ssh-agent {:use-system-ssh-agent false})]\n    (new-identity agent rsa-path)\n    (let\n      [session (new-session agent host username port)]\n      (my-with-connection session 5000\n                          (let [channel (ssh-sftp session)]\n                            (with-channel-connection channel\n                                                     (ssh session {:cmd (apply str \&quot;mkdir -p \&quot; destination)})\n                                                     (sftp channel {} :cd destination)\n                                                     (sftp-put channel input name)))))))\n&quot; &quot;(defn check-progress\n  [f]\n  (let [up-progress (atom 0)]\n    (loop [retries (atom 0)]\n      (try [(f)]\n           (catch Exception e\n             (if (get-in (ex-data e) [:done])\n               (if (&lt; 0 (- (get-in (ex-data e) [:progress]) @up-progress))\n                (reset! up-progress (get-in (ex-data e) [:progress]))\n                (throw e)))))\n      (if (= 0 @retries) \n        (recur retries)))))&quot; &quot;(defn check-progress\n  [f]\n  (let [up-progress (atom 0)]\n    (loop [retries (atom 0)]\n      (try [(f)]\n           (catch Exception e\n             (if (get-in (ex-data e) [:done])\n               (if (&lt; 0 (- (get-in (ex-data e) [:progress]) @up-progress))\n                (reset! up-progress (get-in (ex-data e) [:progress]))\n                (throw e)))))\n      (if (= 0 @retries)\n        (do (prn \&quot;Retry\&quot;) (recur retries))))))&quot; &quot;(defn check-progress\n  [f]\n  (let [up-progress (atom 0)]\n    (loop [retries (atom 0)]\n      (try [(f)]\n           (catch Exception e\n             (if (get-in (ex-data e) [:done])\n               (reset! retries 1)\n               (if (&lt; 0 (- (get-in (ex-data e) [:progress]) @up-progress))\n                (reset! up-progress (get-in (ex-data e) [:progress]))\n                (throw e)))))\n      (if (= 0 @retries)\n        (do (prn \&quot;Retry\&quot;) (recur retries))))))&quot; &quot;(defn check-progress\n  [f]\n  (let [up-progress (atom 0)]\n    (loop [done (atom 0)]\n      (try [(f)]\n           (catch Exception e\n             (if (get-in (ex-data e) [:done])\n               (reset! done 1)\n               (if (&lt; 0 (- (get-in (ex-data e) [:progress]) @up-progress))\n                (reset! up-progress (get-in (ex-data e) [:progress]))\n                (throw e)))))\n      (if (= 0 @done)\n        (do (prn \&quot;Retry\&quot;) (recur done))))))&quot; &quot;(defn state-wrap\n  [state]\n  (let [[operation source destination size done progress continue] state]\n    {:done true :progress 1 }))&quot; &quot;(defn check-progress\n  [f]\n  (let [up-progress (atom 0)]\n    (loop [done (atom 0)]\n      (try [(f)]\n           (reset! done 1)\n           (catch Exception e\n             (if (get-in (ex-data e) [:done])\n               (reset! done 1)\n               (if (&lt; 0 (- (get-in (ex-data e) [:progress]) @up-progress))\n                (reset! up-progress (get-in (ex-data e) [:progress]))\n                (throw e)))))\n      (if (= 0 @done)\n        (do (prn \&quot;Retry\&quot;) (recur done))))))&quot; &quot;(defn state-wrap\n  [state]\n  (let [[operation source destination size done progress continue] state]\n    {:done false :progress 1 }))&quot; &quot;(ns upload-test.core\n  (:gen-class)\n  (:use\n   upload-test.sftp-upload)\n  (:require\n    [clojure.java.io :as io]\n    [again.core :as again]\n    [upload-test.retries :refer :all]\n    [clojure.tools.cli :refer [cli]])\n  (:import org.apache.commons.io.input.BoundedInputStream))\n\n\n(def required-opts #{:host :port :file :destination :username :rsa-path})\n\n(defn missing-required?\n  \&quot;Returns true if opts is missing any of the required-opts\&quot;\n  [opts]\n  (not-every? opts required-opts))\n\n(defn file-size [filename]\n  (.length (io/file filename)))\n\n(defn check-progress\n  [f]\n  (let [up-progress (atom 0)]\n    (loop [retries 0]\n      (try [(f)]\n           (catch Exception e\n             (if (get-in (ex-data e) [:done])\n               (throw (Throwable. \&quot;Success\&quot;))\n               (if (&lt; 0 (- (get-in (ex-data e) [:progress]) @up-progress))\n                (reset! up-progress (get-in (ex-data e) [:progress]))\n                (throw e)))))\n      (recur (inc retries)))))\n\n(defn upload-async\n  [host port input name destination username rsa-path]\n  (future\n    (check-progress #(again/with-retries [100 100 100] (upload-to-sftp host port input name destination username rsa-path)))))\n\n(defn rounded-single-chunk-size\n  [file count]\n  (int (Math/ceil (/ (file-size file) count))))\n\n(defn chunks-list\n  [name start size]\n  {:name (apply str name \&quot;.part\&quot; (str start)) :start (* start size) :size size})\n\n(defn just-chunk\n  [file count]\n  (let [size (rounded-single-chunk-size file count)]\n    (map #(chunks-list file % size) (range count))))\n\n(defn chunk-and-send-file\n  [file count host port destination username rsa-path]\n  (-&gt;&gt;\n    (just-chunk file count)\n    (map\n      #(let [input (io/input-stream file)]\n        (.skip input (get-in % [:start]))\n        (let [bounded (BoundedInputStream. input (get-in % [:size]))]\n          (upload-async host port bounded (get-in % [:name]) destination username rsa-path))))\n    (map deref)\n    (doall)))\n\n(defn chunked_or_standard_upload [opts]\n  (if (:chunks opts)\n    (time\n      (chunk-and-send-file (:file opts) (Integer. (:chunks opts)) (:host opts) (Integer. (:port opts))\n                           (:destination opts) (:username opts) (:rsa-path opts)))\n    (time\n      (check-progress\n        #(again/with-retries\n         [100 100 100]\n         (upload-to-sftp\n           (:host opts) (Integer. (:port opts)) (:file opts)\n           (if (:name opts) (:name opts) (:file opts))\n           (:destination opts) (:username opts) (:rsa-path opts))))\n      )))\n\n(defn -main [&amp; args]\n  (let [[opts args banner] (cli args\n                                [\&quot;-h\&quot; \&quot;--help\&quot; \&quot;Print this help\&quot;\n                                 :default false :flag true]\n                                [\&quot;-c\&quot; \&quot;--chunks\&quot;]\n                                [\&quot;-f\&quot; \&quot;--file\&quot;]\n                                [\&quot;-n\&quot; \&quot;--name\&quot;]\n                                [\&quot;-d\&quot; \&quot;--destination\&quot;]\n                                [\&quot;-u\&quot; \&quot;--username\&quot;]\n                                [\&quot;-ip\&quot; \&quot;--host\&quot;]\n                                [\&quot;-p\&quot; \&quot;--port\&quot;]\n                                [\&quot;-rsa\&quot; \&quot;--rsa-path\&quot;])]\n    (if (or (:help opts)\n              (missing-required? opts))\n      (println banner)\n      (chunked_or_standard_upload opts)\n      )))\n&quot; &quot;(-main \&quot;-c\&quot; \&quot;5\&quot; \&quot;-ip\&quot; \&quot;192.168.1.105\&quot; \&quot;-p\&quot; 22 \&quot;-f\&quot; \&quot;x.txt\&quot; \&quot;-d\&quot; \&quot;Pulpit/takietam/tests\&quot; \&quot;-u\&quot; \&quot;kisiel\&quot; \&quot;-rsa\&quot; \&quot;/home/paveu/.ssh/id_rsa.test\&quot;)&quot; &quot;(ns upload-test.core\n  (:gen-class)\n  (:use\n   upload-test.sftp-upload)\n  (:require\n    [clojure.java.io :as io]\n    [again.core :as again]\n    [upload-test.retries :refer :all]\n    [clojure.tools.cli :refer [cli]])\n  (:import org.apache.commons.io.input.BoundedInputStream))\n\n\n(def required-opts #{:host :port :file :destination :username :rsa-path})\n\n(defn missing-required?\n  \&quot;Returns true if opts is missing any of the required-opts\&quot;\n  [opts]\n  (not-every? opts required-opts))\n\n(defn file-size [filename]\n  (.length (io/file filename)))\n\n(defn check-progress\n  [f]\n  (let [up-progress (atom 0)]\n    (loop [retries 0]\n      (try [(f)]\n           (throw (Throwable. \&quot;Success\&quot;))\n           (catch Exception e\n             (if (get-in (ex-data e) [:done])\n               (throw (Throwable. \&quot;Success\&quot;))\n               (if (&lt; 0 (- (get-in (ex-data e) [:progress]) @up-progress))\n                (reset! up-progress (get-in (ex-data e) [:progress]))\n                (throw e)))))\n      (recur (inc retries)))))\n\n(defn upload-async\n  [host port input name destination username rsa-path]\n  (future\n    (check-progress #(again/with-retries [100 100 100] (upload-to-sftp host port input name destination username rsa-path)))))\n\n(defn rounded-single-chunk-size\n  [file count]\n  (int (Math/ceil (/ (file-size file) count))))\n\n(defn chunks-list\n  [name start size]\n  {:name (apply str name \&quot;.part\&quot; (str start)) :start (* start size) :size size})\n\n(defn just-chunk\n  [file count]\n  (let [size (rounded-single-chunk-size file count)]\n    (map #(chunks-list file % size) (range count))))\n\n(defn chunk-and-send-file\n  [file count host port destination username rsa-path]\n  (-&gt;&gt;\n    (just-chunk file count)\n    (map\n      #(let [input (io/input-stream file)]\n        (.skip input (get-in % [:start]))\n        (let [bounded (BoundedInputStream. input (get-in % [:size]))]\n          (upload-async host port bounded (get-in % [:name]) destination username rsa-path))))\n    (map deref)\n    (doall)))\n\n(defn chunked_or_standard_upload [opts]\n  (if (:chunks opts)\n    (time\n      (chunk-and-send-file (:file opts) (Integer. (:chunks opts)) (:host opts) (Integer. (:port opts))\n                           (:destination opts) (:username opts) (:rsa-path opts)))\n    (time\n      (check-progress\n        #(again/with-retries\n         [100 100 100]\n         (upload-to-sftp\n           (:host opts) (Integer. (:port opts)) (:file opts)\n           (if (:name opts) (:name opts) (:file opts))\n           (:destination opts) (:username opts) (:rsa-path opts))))\n      )))\n\n(defn -main [&amp; args]\n  (let [[opts args banner] (cli args\n                                [\&quot;-h\&quot; \&quot;--help\&quot; \&quot;Print this help\&quot;\n                                 :default false :flag true]\n                                [\&quot;-c\&quot; \&quot;--chunks\&quot;]\n                                [\&quot;-f\&quot; \&quot;--file\&quot;]\n                                [\&quot;-n\&quot; \&quot;--name\&quot;]\n                                [\&quot;-d\&quot; \&quot;--destination\&quot;]\n                                [\&quot;-u\&quot; \&quot;--username\&quot;]\n                                [\&quot;-ip\&quot; \&quot;--host\&quot;]\n                                [\&quot;-p\&quot; \&quot;--port\&quot;]\n                                [\&quot;-rsa\&quot; \&quot;--rsa-path\&quot;])]\n    (if (or (:help opts)\n              (missing-required? opts))\n      (println banner)\n      (chunked_or_standard_upload opts)\n      )))\n\n\n(comment\n\n\n\n  (upload-async \&quot;192.168.1.105\&quot; 22 \&quot;x.txt\&quot; \&quot;lallaa\&quot; \&quot;Pulpit/takietam/tests\&quot; \&quot;kisiel\&quot; \&quot;/home/paveu/.ssh/id_rsa.test\&quot;)\n  (time (chunk-and-send-file \&quot;x.txt\&quot; 5 \&quot;192.168.1.105\&quot; 22 \&quot;Pulpit/takietam/tests\&quot; \&quot;kisiel\&quot; \&quot;/home/paveu/.ssh/id_rsa.test\&quot;))\n  (time (x \&quot;x.txt\&quot; 5 \&quot;192.168.1.105\&quot; 22 \&quot;Pulpit/takietam/tests\&quot; \&quot;kisiel\&quot; \&quot;/home/paveu/.ssh/id_rsa.test\&quot;))\n  (-main \&quot;-ip\&quot; \&quot;192.168.1.105\&quot; \&quot;-p\&quot; 22 \&quot;-f\&quot; \&quot;x.txt\&quot; \&quot;-d\&quot; \&quot;Pulpit/takietam/tests\&quot; \&quot;-u\&quot; \&quot;kisiel\&quot; \&quot;-rsa\&quot; \&quot;/home/paveu/.ssh/id_rsa.test\&quot;)\n  )&quot; &quot;(defn wrap\n  [in]\n  (if (= (type in) Throwable)\n    (prn \&quot;xoxo\&quot;)\n    (throw in)))&quot; &quot;(defn wrap\n  [f]\n  (try [(f)]\n       (catch Exception e)\n       (prn (type e))))&quot; &quot;(defn chunked_or_standard_upload [opts]\n  (if (:chunks opts)\n    (time\n      (chunk-and-send-file (:file opts) (Integer. (:chunks opts)) (:host opts) (Integer. (:port opts))\n                           (:destination opts) (:username opts) (:rsa-path opts)))\n    (time\n      (wrap #(check-progress\n         (again/with-retries\n           [100 100 100]\n           (upload-to-sftp\n             (:host opts) (Integer. (:port opts)) (:file opts)\n             (if (:name opts) (:name opts) (:file opts))\n             (:destination opts) (:username opts) (:rsa-path opts)))))\n      )))&quot; &quot;(defn wrap\n  [f]\n  (try [(f)]\n       (catch Exception e\n         (throw e))))&quot; &quot;(defn check-progress\n  [f]\n  (fn () (let [up-progress (atom 0)]\n     (loop [retries 0]\n       (try [(f)]\n            (throw (Throwable. \&quot;Success\&quot;))\n            (catch Exception e\n              (if (get-in (ex-data e) [:done])\n                (throw (Throwable. \&quot;Success\&quot;))\n                (if (&lt; 0 (- (get-in (ex-data e) [:progress]) @up-progress))\n                  (reset! up-progress (get-in (ex-data e) [:progress]))\n                  (throw e)))))\n       (recur (inc retries))))))&quot; &quot;(defn check-progress\n  [f]\n  (fn []\n    (let [up-progress (atom 0)]\n     (loop [retries 0]\n       (try [(f)]\n            (throw (Throwable. \&quot;Success\&quot;))\n            (catch Exception e\n              (if (get-in (ex-data e) [:done])\n                (throw (Throwable. \&quot;Success\&quot;))\n                (if (&lt; 0 (- (get-in (ex-data e) [:progress]) @up-progress))\n                  (reset! up-progress (get-in (ex-data e) [:progress]))\n                  (throw e)))))\n       (recur (inc retries))))))&quot; &quot;(defn chunked_or_standard_upload [opts]\n  (if (:chunks opts)\n    (time\n      (chunk-and-send-file (:file opts) (Integer. (:chunks opts)) (:host opts) (Integer. (:port opts))\n                           (:destination opts) (:username opts) (:rsa-path opts)))\n    (time\n      (wrap (check-progress\n         #(again/with-retries\n           [100 100 100]\n           (upload-to-sftp\n             (:host opts) (Integer. (:port opts)) (:file opts)\n             (if (:name opts) (:name opts) (:file opts))\n             (:destination opts) (:username opts) (:rsa-path opts)))))\n      )))&quot; &quot;(defn wrap\n  [f]\n  (try [(f)]\n       (catch Exception e\n         (prn (type e)))))&quot; &quot;(defn check-progress\n  [f]\n  (fn []\n    (let [up-progress (atom 0)]\n      (prn (loop [retries 0]\n         (try [(f)]\n              1\n              (catch Exception e\n                (if (get-in (ex-data e) [:done])\n                  1\n                  (if (&lt; 0 (- (get-in (ex-data e) [:progress]) @up-progress))\n                    (reset! up-progress (get-in (ex-data e) [:progress]))\n                    (throw e)))))\n         (recur (inc retries)))))))&quot; &quot;(defn check-progress\n  [f]\n  (let [up-progress (atom 0)]\n    (prn (loop [retries 0]\n           (try [(f)]\n                1\n                (catch Exception e\n                  (if (get-in (ex-data e) [:done])\n                    1\n                    (if (&lt; 0 (- (get-in (ex-data e) [:progress]) @up-progress))\n                      (reset! up-progress (get-in (ex-data e) [:progress]))\n                      (throw e)))))\n           (recur (inc retries))))))&quot; &quot;(defn check-progress\n  [f]\n  (let [up-progress (atom 0)]\n    (loop [retries 0]\n      (if (try [(f)]\n            1\n            (catch Exception e\n              (if (get-in (ex-data e) [:done])\n                1\n                (if (&lt; 0 (- (get-in (ex-data e) [:progress]) @up-progress))\n                  (reset! up-progress (get-in (ex-data e) [:progress]))\n                  (throw e)))))\n        (prn 1)\n        (recur (inc retries)))\n      )))&quot; &quot;(defn state-wrap\n  [state]\n  (let [[operation source destination size done progress continue] state]\n    {:done @done :progress 1 }))&quot; &quot;(defn check-progress\n  [f]\n  (let [up-progress (atom 0)]\n    (loop [retries 0]\n      (prn (try [(f)]\n            1\n            (catch Exception e\n              (if (get-in (ex-data e) [:done])\n                1\n                (if (&lt; 0 (- (get-in (ex-data e) [:progress]) @up-progress))\n                  (reset! up-progress (get-in (ex-data e) [:progress]))\n                  (throw e)))))\n        (prn 1)\n        (recur (inc retries)))\n      )))&quot; &quot;(defn check-progress\n  [f]\n  (let [up-progress (atom 0)]\n    (loop [retries 0]\n      (prn (try [(f)]\n            1\n            (catch Exception e\n              (if (get-in (ex-data e) [:done])\n                1\n                (if (&lt; 0 (- (get-in (ex-data e) [:progress]) @up-progress))\n                  (reset! up-progress (get-in (ex-data e) [:progress]))\n                  (throw e))))))\n      (recur (inc retries)))))&quot; &quot;(defn check-progress\n  [f]\n  (let [up-progress (atom 0)]\n    (loop [retries 0]\n      (prn (try [(f)]\n            (catch Exception e\n              (if (get-in (ex-data e) [:done])\n                (if (&lt; 0 (- (get-in (ex-data e) [:progress]) @up-progress))\n                  (reset! up-progress (get-in (ex-data e) [:progress]))\n                  (throw e))))))\n      (recur (inc retries)))))&quot; &quot;(defn check-progress\n  [f]\n  (let [up-progress (atom 0)]\n    (loop [retries 0]\n      (prn (try [(f)]\n            (catch Exception e\n              (if (&lt; 0 (- (get-in (ex-data e) [:progress]) @up-progress))\n                (reset! up-progress (get-in (ex-data e) [:progress]))\n                (throw e)))))\n      (recur (inc retries)))))&quot; &quot;(defn check-progress\n  [f]\n  (let [up-progress (atom 0)]\n    (loop [retries 0]\n      (prn (try [(f)]\n            (catch Exception e\n              (if (&lt; 0 (- (get-in (ex-data e) [:progress]) @up-progress))\n                (do (reset! up-progress (get-in (ex-data e) [:progress])) nil)\n                (throw e)))))\n      (recur (inc retries)))))&quot; &quot;(defn check-progress\n  [f]\n  (let [up-progress (atom 0)]\n    (loop [retries 0]\n      (if (try [(f)]\n               (catch Exception e\n                 (if (&lt; 0 (- (get-in (ex-data e) [:progress]) @up-progress))\n                   (do (reset! up-progress (get-in (ex-data e) [:progress])) nil)\n                   (throw e))))\n        (prn \&quot;Success\&quot;)\n        (recur (inc retries))))))&quot; &quot;(defn check-progress\n  [f]\n  (let [up-progress (atom 0)]\n    (loop [retries 0]\n      (if (try [(f)]\n               (catch Exception e\n                 (if (&lt; 0 (- (get-in (ex-data e) [:progress]) @up-progress))\n                   (do (reset! up-progress (get-in (ex-data e) [:progress])) nil)\n                   (throw e))))\n        (prn \&quot;Success\&quot;)\n        (do (prn \&quot;Retry\&quot;) (recur (inc retries)))))))&quot; &quot;(defn check-progress\n  [f]\n  (let [up-progress (atom 0)]\n    (loop [retries 0]\n      (if (try [(f)]\n               (catch Exception e\n                 (if (&lt; 0 (- (get-in (ex-data e) [:progress]) @up-progress))\n                   (do (reset! up-progress (get-in (ex-data e) [:progress])) nil)\n                   (throw e))))\n        (prn \&quot;Success\&quot;)\n        (do (prn \&quot;Retry\&quot;) (recur (inc retries)))\n        ))))&quot; &quot;(defn sftp-put\n  [channel input name]\n  (let [[monitor state] (sftp-monitor)]\n    (try\n      ;(sftp channel {:mode :resume :with-monitor monitor}\n      ;     :put input name)\n      1\n      (catch Exception e\n        (throw (ex-info (.getMessage e) (state-wrap state)))))\n    (state-wrap state)))&quot; &quot;(defn state-wrap\n  [state]\n  (let [[operation source destination size done progress continue] state]\n    {:done @done :progress @progress }))&quot; &quot;(ns upload-test.sftp-upload\n  (:use\n    clj-ssh.ssh\n    )\n  (:require\n    [clojure.java.io :as io]\n    [upload-test.retries :refer :all]))\n\n(defmacro my-with-connection\n  \&quot;Creates a context in which the session is connected. Ensures the session is\n  disconnected on exit.\&quot;\n  [session timeout &amp; body]\n  `(let [session# ~session timeout# ~timeout]\n     (try\n       (when-not (connected? session#)\n         (connect session# timeout#))\n       ~@body\n       (finally\n         (disconnect session#)))))\n\n(defn percentage [progress total]\n  (apply str (format \&quot;%.2f\&quot; (float(* 100 (/ progress total)))) \&quot;%\&quot;))\n\n(defn sftp-monitor\n  \&quot;Create a SFTP progress monitor\&quot;\n  []\n  (let [operation (atom nil)\n        source (atom nil)\n        destination (atom nil)\n        size (atom nil)\n        done (atom false)\n        progress (atom 0)\n        continue (atom true)]\n    [ (proxy [com.jcraft.jsch.SftpProgressMonitor] []\n        (init [op src dest max]\n          (do\n            (println (apply str \&quot;Source: \&quot; src \&quot; Destination: \&quot; dest))\n            (reset! operation op)\n            (reset! source src)\n            (reset! destination dest)\n            (reset! size max)\n            (reset! done false)))\n        (count [n]\n          (prn (if (&gt; @size 0)\n                 (percentage @progress @size)\n                 @progress))\n          (swap! progress (partial + n))\n          @continue)\n        (end []\n          (if (&gt; @size 0) (prn \&quot;100,00%\&quot;))\n          (println \&quot;Done\&quot;)\n          (reset! done true)))\n     [operation source destination size done progress continue]]))\n\n\n(defn new-identity\n  [agent rsa-path]\n  (add-identity agent\n                {:private-key-path rsa-path}))\n\n(defn new-session\n  [agent ip username port]\n  (session agent ip\n           {:strict-host-key-checking :no :username username :port port}))\n\n(defn state-wrap\n  [state]\n  (let [[operation source destination size done progress continue] state]\n    {:done @done :progress @progress }))\n\n(defn sftp-put\n  [channel input name]\n  (let [[monitor state] (sftp-monitor)]\n    (try\n      (sftp channel {:mode :resume :with-monitor monitor}\n           :put input name)\n      (catch Exception e\n        (throw (ex-info (.getMessage e) (state-wrap state)))))\n    (state-wrap state)))\n\n(defn upload-to-sftp\n  [host port input name destination username rsa-path]\n  (println \&quot;Starting...\&quot;)\n  (let [agent (ssh-agent {:use-system-ssh-agent false})]\n    (new-identity agent rsa-path)\n    (let\n      [session (new-session agent host username port)]\n      (my-with-connection session 5000\n                          (let [channel (ssh-sftp session)]\n                            (with-channel-connection channel\n                                                     (ssh session {:cmd (apply str \&quot;mkdir -p \&quot; destination)})\n                                                     (sftp channel {} :cd destination)\n                                                     (sftp-put channel input name)))))))\n&quot; &quot;(ns upload-test.core\n  (:gen-class)\n  (:use\n   upload-test.sftp-upload)\n  (:require\n    [clojure.java.io :as io]\n    [again.core :as again]\n    [upload-test.retries :refer :all]\n    [clojure.tools.cli :refer [cli]])\n  (:import org.apache.commons.io.input.BoundedInputStream))\n\n\n(def required-opts #{:host :port :file :destination :username :rsa-path})\n\n(defn missing-required?\n  \&quot;Returns true if opts is missing any of the required-opts\&quot;\n  [opts]\n  (not-every? opts required-opts))\n\n(defn file-size [filename]\n  (.length (io/file filename)))\n\n(defn check-progress\n  [f]\n  (let [up-progress (atom 0)]\n    (loop [retries 0]\n      (if (try [(f)]\n               (catch Exception e\n                 (if (&lt; 0 (- (get-in (ex-data e) [:progress]) @up-progress))\n                   (do (reset! up-progress (get-in (ex-data e) [:progress])) nil)\n                   (throw e))))\n        (prn \&quot;Success\&quot;)\n        (do (prn \&quot;Retry\&quot;) (recur (inc retries)))\n        ))))\n\n(defn upload-async\n  [host port input name destination username rsa-path]\n  (future\n    (check-progress #(again/with-retries [100 100 100] (upload-to-sftp host port input name destination username rsa-path)))))\n\n(defn rounded-single-chunk-size\n  [file count]\n  (int (Math/ceil (/ (file-size file) count))))\n\n(defn chunks-list\n  [name start size]\n  {:name (apply str name \&quot;.part\&quot; (str start)) :start (* start size) :size size})\n\n(defn just-chunk\n  [file count]\n  (let [size (rounded-single-chunk-size file count)]\n    (map #(chunks-list file % size) (range count))))\n\n(defn chunk-and-send-file\n  [file count host port destination username rsa-path]\n  (-&gt;&gt;\n    (just-chunk file count)\n    (map\n      #(let [input (io/input-stream file)]\n        (.skip input (get-in % [:start]))\n        (let [bounded (BoundedInputStream. input (get-in % [:size]))]\n          (upload-async host port bounded (get-in % [:name]) destination username rsa-path))))\n    (map deref)\n    (doall)))\n\n(defn chunked_or_standard_upload [opts]\n  (if (:chunks opts)\n    (time\n      (chunk-and-send-file (:file opts) (Integer. (:chunks opts)) (:host opts) (Integer. (:port opts))\n                           (:destination opts) (:username opts) (:rsa-path opts)))\n    (time\n      (check-progress\n        #(again/with-retries\n          [100 100 100]\n          (upload-to-sftp\n            (:host opts) (Integer. (:port opts)) (:file opts)\n            (if (:name opts) (:name opts) (:file opts))\n            (:destination opts) (:username opts) (:rsa-path opts))))\n      )))\n\n(defn -main [&amp; args]\n  (let [[opts args banner] (cli args\n                                [\&quot;-h\&quot; \&quot;--help\&quot; \&quot;Print this help\&quot;\n                                 :default false :flag true]\n                                [\&quot;-c\&quot; \&quot;--chunks\&quot;]\n                                [\&quot;-f\&quot; \&quot;--file\&quot;]\n                                [\&quot;-n\&quot; \&quot;--name\&quot;]\n                                [\&quot;-d\&quot; \&quot;--destination\&quot;]\n                                [\&quot;-u\&quot; \&quot;--username\&quot;]\n                                [\&quot;-ip\&quot; \&quot;--host\&quot;]\n                                [\&quot;-p\&quot; \&quot;--port\&quot;]\n                                [\&quot;-rsa\&quot; \&quot;--rsa-path\&quot;])]\n    (if (or (:help opts)\n              (missing-required? opts))\n      (println banner)\n      (chunked_or_standard_upload opts)\n      )))\n\n\n(comment\n\n\n\n  (upload-async \&quot;192.168.1.105\&quot; 22 \&quot;x.txt\&quot; \&quot;lallaa\&quot; \&quot;Pulpit/takietam/tests\&quot; \&quot;kisiel\&quot; \&quot;/home/paveu/.ssh/id_rsa.test\&quot;)\n  (time (chunk-and-send-file \&quot;x.txt\&quot; 5 \&quot;192.168.1.105\&quot; 22 \&quot;Pulpit/takietam/tests\&quot; \&quot;kisiel\&quot; \&quot;/home/paveu/.ssh/id_rsa.test\&quot;))\n  (time (x \&quot;x.txt\&quot; 5 \&quot;192.168.1.105\&quot; 22 \&quot;Pulpit/takietam/tests\&quot; \&quot;kisiel\&quot; \&quot;/home/paveu/.ssh/id_rsa.test\&quot;))\n  (-main \&quot;-ip\&quot; \&quot;192.168.1.105\&quot; \&quot;-p\&quot; 22 \&quot;-f\&quot; \&quot;x.txt\&quot; \&quot;-d\&quot; \&quot;Pulpit/takietam/tests\&quot; \&quot;-u\&quot; \&quot;kisiel\&quot; \&quot;-rsa\&quot; \&quot;/home/paveu/.ssh/id_rsa.test\&quot;)\n  )&quot; &quot;(defn sftp-put\n  [channel input name]\n  (let [[monitor state] (sftp-monitor)]\n    (try\n      ;(sftp channel {:mode :resume :with-monitor monitor}\n      ;     :put input name)\n      (throw (Exception. \&quot;eueue\&quot;))\n      (catch Exception e\n        (throw (ex-info (.getMessage e) (state-wrap state)))))\n    (state-wrap state)))&quot; &quot;(defn upload-to-sftp\n  [host port input name destination username rsa-path]\n  (println \&quot;Starting...\&quot;)\n  (let [agent (ssh-agent {:use-system-ssh-agent false})]\n    (new-identity agent rsa-path)\n    (try\n      (let\n       [session (new-session agent host username port)]\n       (my-with-connection session 5000\n                           (let [channel (ssh-sftp session)]\n                             (with-channel-connection channel\n                                                      (ssh session {:cmd (apply str \&quot;mkdir -p \&quot; destination)})\n                                                      (sftp channel {} :cd destination)\n                                                      (sftp-put channel input name)))))\n      (catch Exception e\n        (throw e)))))&quot; &quot;(defn upload-to-sftp\n  [host port input name destination username rsa-path]\n  (println \&quot;Starting...\&quot;)\n  (let [agent (ssh-agent {:use-system-ssh-agent false})]\n    (new-identity agent rsa-path)\n    (try\n      (let\n       [session (new-session agent host username port)]\n       (my-with-connection session 5000\n                           (let [channel (ssh-sftp session)]\n                             (with-channel-connection channel\n                                                      (ssh session {:cmd (apply str \&quot;mkdir -p \&quot; destination)})\n                                                      (sftp channel {} :cd destination)\n                                                      (sftp-put channel input name)))))\n      (catch Exception e\n        (throw (Exception \&quot;eueue\&quot;))))))&quot; &quot;(defn upload-to-sftp\n  [host port input name destination username rsa-path]\n  (println \&quot;Starting...\&quot;)\n  (let [agent (ssh-agent {:use-system-ssh-agent false})]\n    (new-identity agent rsa-path)\n    (try\n      (let\n       [session (new-session agent host username port)]\n       (my-with-connection session 5000\n                           (let [channel (ssh-sftp session)]\n                             (with-channel-connection channel\n                                                      (ssh session {:cmd (apply str \&quot;mkdir -p \&quot; destination)})\n                                                      (sftp channel {} :cd destination)\n                                                      (sftp-put channel input name)))))\n      (catch Exception e\n        (throw (Exception. \&quot;eueue\&quot;))))))&quot; &quot;(defn new-session\n  [agent ip username port]\n  (try\n    (session agent ip\n            {:strict-host-key-checking :no :username username :port port})\n    (catch Exception e\n      (throw (Exception. \&quot;Eueue\&quot;)))))&quot; &quot;(defn new-identity\n  [agent rsa-path]\n  (prn \&quot;sss\&quot;)\n  (add-identity agent\n                {:private-key-path rsa-path}))&quot; &quot;(defn new-session\n  [agent ip username port]\n  (prn \&quot;sss\&quot;)\n  (try\n    (session agent ip\n            {:strict-host-key-checking :no :username username :port port})\n    (catch Exception e\n      (throw (Exception. \&quot;Eueue\&quot;)))))&quot; &quot;(defn new-identity\n  [agent rsa-path]\n  (add-identity agent\n                {:private-key-path rsa-path}))&quot; &quot;(defn new-session\n  [agent ip username port]\n  (try\n    (session agent ip\n            {:strict-host-key-checking :no :username username :port port})\n    (catch Exception e\n      (throw (Exception. \&quot;Eueue\&quot;))))\n  (prn \&quot;sss\&quot;))&quot; &quot;(defn upload-to-sftp\n  [host port input name destination username rsa-path]\n  (println \&quot;Starting...\&quot;)\n  (let [agent (ssh-agent {:use-system-ssh-agent false})]\n    (new-identity agent rsa-path)\n    (let\n      [session (new-session agent host username port)]\n      (prn session)\n      (my-with-connection session 5000\n                          (let [channel (ssh-sftp session)]\n                            (with-channel-connection channel\n                                                     (ssh session {:cmd (apply str \&quot;mkdir -p \&quot; destination)})\n                                                     (sftp channel {} :cd destination)\n                                                     (sftp-put channel input name)))))))&quot; &quot;(defn upload-to-sftp\n  [host port input name destination username rsa-path]\n  (println \&quot;Starting...\&quot;)\n  (let [agent (ssh-agent {:use-system-ssh-agent false})]\n    (new-identity agent rsa-path)\n    (let\n      [session (new-session agent host username port)]\n      (my-with-connection session 5000\n                          (prn \&quot;sss\&quot;)\n                          (let [channel (ssh-sftp session)]\n                            (with-channel-connection channel\n                                                     (ssh session {:cmd (apply str \&quot;mkdir -p \&quot; destination)})\n                                                     (sftp channel {} :cd destination)\n                                                     (sftp-put channel input name)))))))&quot; &quot;(defn upload-to-sftp\n  [host port input name destination username rsa-path]\n  (println \&quot;Starting...\&quot;)\n  (let [agent (ssh-agent {:use-system-ssh-agent false})]\n    (new-identity agent rsa-path)\n    (let\n      [session (new-session agent host username port)]\n      (my-with-connection session 5000\n                          (let [channel (ssh-sftp session)]\n                            (with-channel-connection channel\n                                                     (ssh session {:cmd (apply str \&quot;mkdir -p \&quot; destination)})\n                                                     (sftp channel {} :cd destination)\n                                                     (sftp-put channel input name)))))))&quot; &quot;(defmacro my-with-connection\n  \&quot;Creates a context in which the session is connected. Ensures the session is\n  disconnected on exit.\&quot;\n  [session timeout &amp; body]\n  `(let [session# ~session timeout# ~timeout]\n     (try\n       (when-not (connected? session#)\n         (prn 1)\n         (connect session# timeout#)\n         (prn 2))\n       ~@body\n       (finally\n         (disconnect session#)))))&quot; &quot;(defmacro my-with-connection\n  \&quot;Creates a context in which the session is connected. Ensures the session is\n  disconnected on exit.\&quot;\n  [session timeout &amp; body]\n  (prn 1)\n  `(let [session# ~session timeout# ~timeout]\n     (try\n       (when-not (connected? session#)\n         (connect session# timeout#))\n       ~@body\n       (finally\n         (disconnect session#)))))&quot; &quot;(defn upload-to-sftp\n  [host port input name destination username rsa-path]\n  (println \&quot;Starting...\&quot;)\n  (let [agent (ssh-agent {:use-system-ssh-agent false})]\n    (new-identity agent rsa-path)\n    (let\n      [session (new-session agent host username port)]\n      (prn \&quot;sss\&quot;)\n      (my-with-connection session 5000\n                          (let [channel (ssh-sftp session)]\n                            (with-channel-connection channel\n                                                     (ssh session {:cmd (apply str \&quot;mkdir -p \&quot; destination)})\n                                                     (sftp channel {} :cd destination)\n                                                     (sftp-put channel input name)))))))&quot; &quot;(defmacro my-with-connection\n  \&quot;Creates a context in which the session is connected. Ensures the session is\n  disconnected on exit.\&quot;\n  [session timeout &amp; body]\n  (prn \&quot;sss\&quot;)\n  `(let [session# ~session timeout# ~timeout]\n     (try\n       (when-not (connected? session#)\n         (connect session# timeout#))\n       ~@body\n       (finally\n         (disconnect session#)))))&quot; &quot;(defn upload-to-sftp\n  [host port input name destination username rsa-path]\n  (println \&quot;Starting...\&quot;)\n  (let [agent (ssh-agent {:use-system-ssh-agent false})]\n    (new-identity agent rsa-path)\n    (let\n      [session (new-session agent host username port)]\n      (prn \&quot;eee\&quot;)\n      (my-with-connection session 5000\n                          (let [channel (ssh-sftp session)]\n                            (with-channel-connection channel\n                                                     (ssh session {:cmd (apply str \&quot;mkdir -p \&quot; destination)})\n                                                     (sftp channel {} :cd destination)\n                                                     (sftp-put channel input name)))))))&quot; &quot;(defn upload-to-sftp\n  [host port input name destination username rsa-path]\n  (println \&quot;Starting...\&quot;)\n  (let [agent (ssh-agent {:use-system-ssh-agent false})]\n    (new-identity agent rsa-path)\n    (let [session (new-session agent host username port)]\n      (with-connection session\n                          (let [channel (ssh-sftp session)]\n                            (with-channel-connection channel\n                                                     (ssh session {:cmd (apply str \&quot;mkdir -p \&quot; destination)})\n                                                     (sftp channel {} :cd destination)\n                                                     (sftp-put channel input name)))))))&quot; &quot;(defn my-new-session\n  [agent ip username port]\n  (try (session agent ip\n            {:strict-host-key-checking :no :username username :port port})\n       (catch Exception e\n         (throw (Exception. \&quot;eu\&quot;)))))&quot; &quot;(defn upload-to-sftp\n  [host port input name destination username rsa-path]\n  (println \&quot;Starting...\&quot;)\n  (let [agent (ssh-agent {:use-system-ssh-agent false})]\n    (new-identity agent rsa-path)\n    (let [session (new-session agent host username port)]\n      (my-with-connection session 5000\n                          (let [channel (ssh-sftp session)]\n                            (with-channel-connection channel\n                                                     (ssh session {:cmd (apply str \&quot;mkdir -p \&quot; destination)})\n                                                     (sftp channel {} :cd destination)\n                                                     (sftp-put channel input name)))))))&quot; &quot;(defn upload-to-sftp\n  [host port input name destination username rsa-path]\n  (println \&quot;Starting...\&quot;)\n  (let [agent (ssh-agent {:use-system-ssh-agent false})]\n    (new-identity agent rsa-path)\n    (let [session (my-new-session agent host username port)]\n      (my-with-connection session 5000\n                          (let [channel (ssh-sftp session)]\n                            (with-channel-connection channel\n                                                     (ssh session {:cmd (apply str \&quot;mkdir -p \&quot; destination)})\n                                                     (sftp channel {} :cd destination)\n                                                     (sftp-put channel input name)))))))&quot; &quot;(defn my-new-session\n  [agent ip username port]\n  (prn (session agent ip\n            {:strict-host-key-checking :no :username username :port port})))&quot; &quot;(defn my-new-session\n  [agent ip username port]\n  (prn @(session agent ip\n            {:strict-host-key-checking :no :username username :port port})))&quot; &quot;(defn upload-to-sftp\n  [host port input name destination username rsa-path]\n  (println \&quot;Starting...\&quot;)\n  (let [agent (ssh-agent {:use-system-ssh-agent false})]\n    (new-identity agent rsa-path)\n    (let [session (new-session agent host username port)]\n      (my-with-connection session 5000\n                          1\n                          ;(let [channel (ssh-sftp session)]\n                          ;  (with-channel-connection channel\n                          ;                           (ssh session {:cmd (apply str \&quot;mkdir -p \&quot; destination)})\n                          ;                           (sftp channel {} :cd destination)\n                          ;                           (sftp-put channel input name)))\n                          ))))&quot; &quot;(defn new-session\n  [agent ip username port]\n  (session agent ip\n           {:strict-host-key-checking :no :username username :port port}))&quot; &quot;(defn upload-to-sftp\n  [host port input name destination username rsa-path]\n  (println \&quot;Starting...\&quot;)\n  (let [agent (ssh-agent {:use-system-ssh-agent false})]\n    (new-identity agent rsa-path)\n    (let [session (new-session agent host username port)]\n      1\n      ;(my-with-connection session 5000\n                          ;(let [channel (ssh-sftp session)]\n                          ;  (with-channel-connection channel\n                          ;                           (ssh session {:cmd (apply str \&quot;mkdir -p \&quot; destination)})\n                          ;                           (sftp channel {} :cd destination)\n                          ;                           (sftp-put channel input name))))\n      )))&quot; &quot;(defmacro my-with-connection\n  \&quot;Creates a context in which the session is connected. Ensures the session is\n  disconnected on exit.\&quot;\n  [session timeout &amp; body]\n  `(let [session# ~session timeout# ~timeout]\n     (try\n       (when-not (connected? session#)\n         (connect session# timeout#))\n       ~@body\n       (catch Exception e\n         (throw (Exception. \&quot;eueue\&quot;)))\n       (finally\n         (disconnect session#)))))&quot; &quot;(defmacro my-with-connection\n  \&quot;Creates a context in which the session is connected. Ensures the session is\n  disconnected on exit.\&quot;\n  [session timeout &amp; body]\n  `(let [session# ~session timeout# ~timeout]\n     (try\n       (when-not (connected? session#)\n         (connect session# timeout#))\n       ~@body\n       (finally\n         (disconnect session#)))))&quot; &quot;(ns upload-test.sftp-upload\n  (:use\n    clj-ssh.ssh\n    )\n  (:require\n    [again.core :as again]\n    [clojure.java.io :as io]\n    [upload-test.retries :refer :all]))\n&quot; &quot;(defn upload-to-sftp\n  [host port input name destination username rsa-path]\n  (println \&quot;Starting...\&quot;)\n  (let [agent (ssh-agent {:use-system-ssh-agent false})]\n    (new-identity agent rsa-path)\n    (let [session (new-session agent host username port)]\n      (my-with-connection session 5000\n                          (let [channel (ssh-sftp session)]\n                            (with-channel-connection channel\n                                                     (again/with-retries\n                                                       (do\n                                                        (ssh session {:cmd (apply str \&quot;mkdir -p \&quot; destination)})\n                                                        (sftp channel {} :cd destination)\n                                                        (sftp-put channel input name))))))\n      )))&quot; &quot;(defn upload-to-sftp\n  [host port input name destination username rsa-path]\n  (println \&quot;Starting...\&quot;)\n  (let [agent (ssh-agent {:use-system-ssh-agent false})]\n    (new-identity agent rsa-path)\n    (let [session (new-session agent host username port)]\n      (my-with-connection session 5000\n                          (let [channel (ssh-sftp session)]\n                            (with-channel-connection channel\n                                                     (again/with-retries [100 100 100]\n                                                       (do\n                                                        (ssh session {:cmd (apply str \&quot;mkdir -p \&quot; destination)})\n                                                        (sftp channel {} :cd destination)\n                                                        (sftp-put channel input name))))))\n      )))&quot; &quot;(defn chunked_or_standard_upload [opts]\n  (if (:chunks opts)\n    (time\n      (chunk-and-send-file (:file opts) (Integer. (:chunks opts)) (:host opts) (Integer. (:port opts))\n                           (:destination opts) (:username opts) (:rsa-path opts)))\n    (time\n      (upload-to-sftp\n        (:host opts) (Integer. (:port opts)) (:file opts)\n        (if (:name opts) (:name opts) (:file opts))\n        (:destination opts) (:username opts) (:rsa-path opts))\n      )))&quot; &quot;(defn upload-to-sftp\n  [host port input name destination username rsa-path]\n  (println \&quot;Starting...\&quot;)\n  (let [agent (ssh-agent {:use-system-ssh-agent false})]\n    (new-identity agent rsa-path)\n    (let [session (new-session agent host username port)]\n      (my-with-connection session 5000\n                          (let [channel (ssh-sftp session)]\n                            (with-channel-connection channel\n                                                     (ssh session {:cmd (apply str \&quot;mkdir -p \&quot; destination)})\n                                                     (sftp channel {} :cd destination)\n                                                     (sftp-put channel input name))))\n      )))&quot; &quot;(defn check-progress*\n  [up-progress f]\n  (if-let [[res] (try\n                   [(f)]\n                   (catch Exception e\n                     (if (&lt; 0 (- (get-in (ex-data e) [:progress]) @up-progress))\n                       (do (reset! up-progress (get-in (ex-data e) [:progress])) nil)\n                       (throw e))))]\n    res\n    (recur up-progress f)))\n\n(defmacro check-progress\n  [&amp; body]\n  `(check-progress* (atom 0) (fn [] ~@body)))&quot; &quot;(defmacro check-progress\n  [body]\n  `(check-progress* (atom 0) (fn [] ~@body)))&quot; &quot;(defmacro check-progress\n  [up &amp; body]\n  `(check-progress* (atom up) (fn [] ~@body)))&quot; &quot;(defmacro check-progress\n  [up &amp; body]\n  `(check-progress* (atom ~up) (fn [] ~@body)))&quot; &quot;(defn chunked_or_standard_upload [opts]\n  (if (:chunks opts)\n    (time\n      (chunk-and-send-file (:file opts) (Integer. (:chunks opts)) (:host opts) (Integer. (:port opts))\n                           (:destination opts) (:username opts) (:rsa-path opts)))\n    (time\n      (check-progress 0\n        #(again/with-retries\n          [100 100 100]\n          (upload-to-sftp\n            (:host opts) (Integer. (:port opts)) (:file opts)\n            (if (:name opts) (:name opts) (:file opts))\n            (:destination opts) (:username opts) (:rsa-path opts))))\n      )))&quot; &quot;(defn chunked_or_standard_upload [opts]\n  (if (:chunks opts)\n    (time\n      (chunk-and-send-file (:file opts) (Integer. (:chunks opts)) (:host opts) (Integer. (:port opts))\n                           (:destination opts) (:username opts) (:rsa-path opts)))\n    (time\n      (check-progress 0\n        (again/with-retries\n          [100 100 100]\n          (upload-to-sftp\n            (:host opts) (Integer. (:port opts)) (:file opts)\n            (if (:name opts) (:name opts) (:file opts))\n            (:destination opts) (:username opts) (:rsa-path opts))))\n      )))&quot; &quot;(defn chunked_or_standard_upload [opts]\n  (if (:chunks opts)\n    (time\n      (chunk-and-send-file (:file opts) (Integer. (:chunks opts)) (:host opts) (Integer. (:port opts))\n                           (:destination opts) (:username opts) (:rsa-path opts)))\n    (time\n      (again/with-retries\n        [100 100 100]\n        (upload-to-sftp\n          (:host opts) (Integer. (:port opts)) (:file opts)\n          (if (:name opts) (:name opts) (:file opts))\n          (:destination opts) (:username opts) (:rsa-path opts)))\n      )))&quot; &quot;(defn check-progress\n  [f]\n  (try (f))\n  ;(let [up-progress (atom 0)]\n  ;  (loop [retries 0]\n  ;    (if (try [(f)]\n  ;             (catch Exception e\n  ;               (if (&lt; 0 (- (get-in (ex-data e) [:progress]) @up-progress))\n  ;                 (do (reset! up-progress (get-in (ex-data e) [:progress])) nil)\n  ;                 (throw e))))\n  ;      (prn \&quot;Success\&quot;)\n  ;      (do (prn \&quot;Retry\&quot;) (recur (inc retries)))\n  ;      )))\n  )&quot; &quot;(defn check-progress\n  [f]\n  (try [(f)])\n  ;(let [up-progress (atom 0)]\n  ;  (loop [retries 0]\n  ;    (if (try [(f)]\n  ;             (catch Exception e\n  ;               (if (&lt; 0 (- (get-in (ex-data e) [:progress]) @up-progress))\n  ;                 (do (reset! up-progress (get-in (ex-data e) [:progress])) nil)\n  ;                 (throw e))))\n  ;      (prn \&quot;Success\&quot;)\n  ;      (do (prn \&quot;Retry\&quot;) (recur (inc retries)))\n  ;      )))\n  )&quot; &quot;(defn check-progress\n  [f]\n  (let [up-progress (atom 0)]\n    (loop [retries 0]\n      (if (try [(f)]\n               (catch Exception e\n                 (if (&lt; 0 (- (get-in (ex-data e) [:progress]) @up-progress))\n                   (do (reset! up-progress (get-in (ex-data e) [:progress])) nil)\n                   (throw e))))\n        (prn \&quot;Success\&quot;)\n        (do (prn \&quot;Retry\&quot;) (recur (inc retries)))\n        )))\n  )&quot; &quot;(ns upload-test.core\n  (:gen-class)\n  (:use\n   upload-test.sftp-upload)\n  (:require\n    [clojure.java.io :as io]\n    [again.core :as again]\n    [upload-test.retries :refer :all]\n    [clojure.tools.cli :refer [cli]])\n  (:import org.apache.commons.io.input.BoundedInputStream))\n\n\n(def required-opts #{:host :port :file :destination :username :rsa-path})\n\n(defn missing-required?\n  \&quot;Returns true if opts is missing any of the required-opts\&quot;\n  [opts]\n  (not-every? opts required-opts))\n\n(defn file-size [filename]\n  (.length (io/file filename)))\n\n(defn check-progress\n  [f]\n  (let [up-progress (atom 0)]\n    (loop [retries 0]\n      (if (try [(f)]\n               (catch Exception e\n                 (if (&lt; 0 (- (get-in (ex-data e) [:progress]) @up-progress))\n                   (do (reset! up-progress (get-in (ex-data e) [:progress])) nil)\n                   (throw e))))\n        (prn \&quot;Success\&quot;)\n        (do (prn \&quot;Retry\&quot;) (recur (inc retries)))\n        )))\n  )\n\n(defn upload-async\n  [host port input name destination username rsa-path]\n  (future\n    (check-progress #(again/with-retries [100 100 100] (upload-to-sftp host port input name destination username rsa-path)))))\n\n(defn rounded-single-chunk-size\n  [file count]\n  (int (Math/ceil (/ (file-size file) count))))\n\n(defn chunks-list\n  [name start size]\n  {:name (apply str name \&quot;.part\&quot; (str start)) :start (* start size) :size size})\n\n(defn just-chunk\n  [file count]\n  (let [size (rounded-single-chunk-size file count)]\n    (map #(chunks-list file % size) (range count))))\n\n(defn chunk-and-send-file\n  [file count host port destination username rsa-path]\n  (-&gt;&gt;\n    (just-chunk file count)\n    (map\n      #(let [input (io/input-stream file)]\n        (.skip input (get-in % [:start]))\n        (let [bounded (BoundedInputStream. input (get-in % [:size]))]\n          (upload-async host port bounded (get-in % [:name]) destination username rsa-path))))\n    (map deref)\n    (doall)))\n\n(defn chunked_or_standard_upload [opts]\n  (if (:chunks opts)\n    (time\n      (chunk-and-send-file (:file opts) (Integer. (:chunks opts)) (:host opts) (Integer. (:port opts))\n                           (:destination opts) (:username opts) (:rsa-path opts)))\n    (time\n      (check-progress\n        #(again/with-retries\n          [100 100 100]\n          (upload-to-sftp\n            (:host opts) (Integer. (:port opts)) (:file opts)\n            (if (:name opts) (:name opts) (:file opts))\n            (:destination opts) (:username opts) (:rsa-path opts))))\n      )))\n\n(defn -main [&amp; args]\n  (let [[opts args banner] (cli args\n                                [\&quot;-h\&quot; \&quot;--help\&quot; \&quot;Print this help\&quot;\n                                 :default false :flag true]\n                                [\&quot;-c\&quot; \&quot;--chunks\&quot;]\n                                [\&quot;-f\&quot; \&quot;--file\&quot;]\n                                [\&quot;-n\&quot; \&quot;--name\&quot;]\n                                [\&quot;-d\&quot; \&quot;--destination\&quot;]\n                                [\&quot;-u\&quot; \&quot;--username\&quot;]\n                                [\&quot;-ip\&quot; \&quot;--host\&quot;]\n                                [\&quot;-p\&quot; \&quot;--port\&quot;]\n                                [\&quot;-rsa\&quot; \&quot;--rsa-path\&quot;])]\n    (if (or (:help opts)\n              (missing-required? opts))\n      (println banner)\n      (chunked_or_standard_upload opts)\n      )))\n\n\n(comment\n\n\n\n  (upload-async \&quot;192.168.1.105\&quot; 22 \&quot;x.txt\&quot; \&quot;lallaa\&quot; \&quot;Pulpit/takietam/tests\&quot; \&quot;kisiel\&quot; \&quot;/home/paveu/.ssh/id_rsa.test\&quot;)\n  (time (chunk-and-send-file \&quot;x.txt\&quot; 5 \&quot;192.168.1.105\&quot; 22 \&quot;Pulpit/takietam/tests\&quot; \&quot;kisiel\&quot; \&quot;/home/paveu/.ssh/id_rsa.test\&quot;))\n  (time (x \&quot;x.txt\&quot; 5 \&quot;192.168.1.105\&quot; 22 \&quot;Pulpit/takietam/tests\&quot; \&quot;kisiel\&quot; \&quot;/home/paveu/.ssh/id_rsa.test\&quot;))\n  (-main \&quot;-ip\&quot; \&quot;192.168.1.105\&quot; \&quot;-p\&quot; 22 \&quot;-f\&quot; \&quot;x.txt\&quot; \&quot;-d\&quot; \&quot;Pulpit/takietam/tests\&quot; \&quot;-u\&quot; \&quot;kisiel\&quot; \&quot;-rsa\&quot; \&quot;/home/paveu/.ssh/id_rsa.test\&quot;)\n  )&quot; &quot;(defn check-progress\n  [f]\n  (f)\n  ;(let [up-progress (atom 0)]\n  ;  (loop [retries 0]\n  ;    (if (try [(f)]\n  ;             (catch Exception e\n  ;               (if (&lt; 0 (- (get-in (ex-data e) [:progress]) @up-progress))\n  ;                 (do (reset! up-progress (get-in (ex-data e) [:progress])) nil)\n  ;                 (throw e))))\n  ;      (prn \&quot;Success\&quot;)\n  ;      (do (prn \&quot;Retry\&quot;) (recur (inc retries)))\n  ;      )))\n  )&quot; &quot;(defn check-progress\n  [f]\n  (let [up-progress (atom 0)]\n    (loop [retries 0]\n      (if (try (f)\n               (catch Exception e\n                 (if (&lt; 0 (- (get-in (ex-data e) [:progress]) 0))\n                   (do (reset! up-progress (get-in (ex-data e) [:progress])) nil)\n                   (throw e))))\n        (prn \&quot;Success\&quot;)\n        (do (prn \&quot;Retry\&quot;) (recur (inc retries)))\n        )))\n  )&quot; &quot;(defn check-progress\n  [f]\n  (loop [retries 0]\n    (try (f)\n         (catch Exception e\n           (throw e))))\n\n  ;(let [up-progress (atom 0)]\n  ;  (loop [retries 0]\n  ;    (if (try (f)\n  ;             (catch Exception e\n  ;               (if (&lt; 0 (- (get-in (ex-data e) [:progress]) @up-progress))\n  ;                 (do (reset! up-progress (get-in (ex-data e) [:progress])) nil)\n  ;                 (throw e))))\n  ;      (prn \&quot;Success\&quot;)\n  ;      (do (prn \&quot;Retry\&quot;) (recur (inc retries)))\n  ;      )))\n  )&quot; &quot;(defn check-progress\n  [f]\n  (loop [retries 0]\n    (try (f)\n         (catch Exception e\n           (throw e)))\n    (recur 0))\n\n  ;(let [up-progress (atom 0)]\n  ;  (loop [retries 0]\n  ;    (if (try (f)\n  ;             (catch Exception e\n  ;               (if (&lt; 0 (- (get-in (ex-data e) [:progress]) @up-progress))\n  ;                 (do (reset! up-progress (get-in (ex-data e) [:progress])) nil)\n  ;                 (throw e))))\n  ;      (prn \&quot;Success\&quot;)\n  ;      (do (prn \&quot;Retry\&quot;) (recur (inc retries)))\n  ;      )))\n  )&quot; &quot;(defn check-progress\n  [f]\n  (loop [retries 0]\n    (try (f)\n         (catch Exception e\n           (if (= 2 retries) (throw e))))\n    (recur (inc retries)))\n\n  ;(let [up-progress (atom 0)]\n  ;  (loop [retries 0]\n  ;    (if (try (f)\n  ;             (catch Exception e\n  ;               (if (&lt; 0 (- (get-in (ex-data e) [:progress]) @up-progress))\n  ;                 (do (reset! up-progress (get-in (ex-data e) [:progress])) nil)\n  ;                 (throw e))))\n  ;      (prn \&quot;Success\&quot;)\n  ;      (do (prn \&quot;Retry\&quot;) (recur (inc retries)))\n  ;      )))\n  )&quot; &quot;(defn check-progress\n  [f]\n  (loop [retries 0]\n    (try (f)\n         (catch Exception e\n           (if (= 2 retries) (throw e))))\n    (do (prn \&quot;Retry\&quot;) (recur (inc retries))))\n\n  ;(let [up-progress (atom 0)]\n  ;  (loop [retries 0]\n  ;    (if (try (f)\n  ;             (catch Exception e\n  ;               (if (&lt; 0 (- (get-in (ex-data e) [:progress]) @up-progress))\n  ;                 (do (reset! up-progress (get-in (ex-data e) [:progress])) nil)\n  ;                 (throw e))))\n  ;      (prn \&quot;Success\&quot;)\n  ;      (do (prn \&quot;Retry\&quot;) (recur (inc retries)))\n  ;      )))\n  )&quot; &quot;(defn upload-to-sftp\n  [host port input name destination username rsa-path]\n  (println \&quot;Starting...\&quot;)\n  (let [agent (ssh-agent {:use-system-ssh-agent false})]\n    (new-identity agent rsa-path)\n    (let [session (new-session agent host username port)]\n      (try\n        (my-with-connection session 5000\n                           (let [channel (ssh-sftp session)]\n                             (with-channel-connection channel\n                                                      (ssh session {:cmd (apply str \&quot;mkdir -p \&quot; destination)})\n                                                      (sftp channel {} :cd destination)\n                                                      (sftp-put channel input name))))\n        (catch Exception e\n          (throw (Exception. \&quot;eueu\&quot;))))\n      )))&quot; &quot;(defn upload-to-sftp\n  [host port input name destination username rsa-path]\n  (println \&quot;Starting...\&quot;)\n  (let [agent (ssh-agent {:use-system-ssh-agent false})]\n    (new-identity agent rsa-path)\n    (let [session (new-session agent host username port)]\n      (let [progress (atom 0)]\n        (try\n         (my-with-connection session 5000\n                             (let [channel (ssh-sftp session)]\n                               (with-channel-connection channel\n                                                        (ssh session {:cmd (apply str \&quot;mkdir -p \&quot; destination)})\n                                                        (sftp channel {} :cd destination)\n                                                        (reset! progress (sftp-put channel input name)))))\n         (catch Exception e\n           (throw (ex-info (.getMessage e) {:progress 1})))))\n      )))&quot; &quot;      (sftp channel {:mode :resume :with-monitor monitor}\n           :put input name)&quot; &quot;(defn sftp-put\n  [channel input name]\n  (let [[monitor state] (sftp-monitor)]\n    (try\n      (sftp channel {:mode :resume :with-monitor monitor}\n           :put input name)\n      (catch Exception e\n        (throw (ex-info (.getMessage e) (state-wrap state)))))\n    (state-wrap state)))&quot; &quot;-main&quot; &quot;(-main \&quot;-ip\&quot; \&quot;192.168.1.105\&quot; \&quot;-p\&quot; 22 \&quot;-f\&quot; \&quot;x.txt\&quot; \&quot;-d\&quot; \&quot;Pulpit/takietam/tests\&quot; \&quot;-u\&quot; \&quot;kisiel\&quot; \&quot;-rsa\&quot; \&quot;/home/paveu/.ssh/id_rsa.test\&quot;)&quot; &quot;(defn chunked_or_standard_upload [opts]\n  (if (:chunks opts)\n    (time\n      (chunk-and-send-file (:file opts) (Integer. (:chunks opts)) (:host opts) (Integer. (:port opts))\n                           (:destination opts) (:username opts) (:rsa-path opts)))\n    (time\n      (let [progress (atom 0)]\n        (check-progress\n         (again/with-retries\n           [100 100 100]\n           (upload-to-sftp\n             (:host opts) (Integer. (:port opts)) (:file opts)\n             (if (:name opts) (:name opts) (:file opts))\n             (:destination opts) (:username opts) (:rsa-path opts) progress))))\n      )))&quot; &quot;(defn check-progress\n  [f]\n  (let [up-progress (atom 0)]\n    (loop [retries 0]\n      (if (try (fn [] f)\n               (catch Exception e\n                 (if (&lt; 0 (- (get-in (ex-data e) [:progress]) @up-progress))\n                   (do (reset! up-progress (get-in (ex-data e) [:progress])) nil)\n                   (throw e))))\n        (prn \&quot;Success\&quot;)\n        (do (prn \&quot;Retry\&quot;) (recur (inc retries)))\n        )))\n  )&quot; &quot;(defn chunked_or_standard_upload [opts]\n  (if (:chunks opts)\n    (time\n      (chunk-and-send-file (:file opts) (Integer. (:chunks opts)) (:host opts) (Integer. (:port opts))\n                           (:destination opts) (:username opts) (:rsa-path opts)))\n    (time\n      (let [progress (atom 0)]\n        (check-progress\n         #(again/with-retries\n           [100 100 100]\n           (upload-to-sftp\n             (:host opts) (Integer. (:port opts)) (:file opts)\n             (if (:name opts) (:name opts) (:file opts))\n             (:destination opts) (:username opts) (:rsa-path opts) progress))))\n      )))&quot; &quot;(defn check-progress\n  [f]\n  (let [up-progress (atom 0)]\n    (loop [retries 0]\n      (if (try (f)\n               (catch Exception e\n                 (if (&lt; 0 (- (get-in (ex-data e) [:progress]) @up-progress))\n                   (do (reset! up-progress (get-in (ex-data e) [:progress])) nil)\n                   (throw e))))\n        (prn \&quot;Success\&quot;)\n        (do (prn \&quot;Retry\&quot;) (recur (inc retries)))\n        )))\n  )&quot; &quot;(defn chunked_or_standard_upload [opts]\n  (if (:chunks opts)\n    (time\n      (chunk-and-send-file (:file opts) (Integer. (:chunks opts)) (:host opts) (Integer. (:port opts))\n                           (:destination opts) (:username opts) (:rsa-path opts)))\n    (time\n      (check-progress\n        #(again/with-retries\n          [100 100 100]\n          (upload-to-sftp\n            (:host opts) (Integer. (:port opts)) (:file opts)\n            (if (:name opts) (:name opts) (:file opts))\n            (:destination opts) (:username opts) (:rsa-path opts))))\n      )))&quot; &quot;(defn upload-to-sftp\n  [host port input name destination username rsa-path progress]\n  (println \&quot;Starting...\&quot;)\n  (let [agent (ssh-agent {:use-system-ssh-agent false})]\n    (new-identity agent rsa-path)\n    (let [session (new-session agent host username port)]\n      (let [progress (atom 0)]\n        (try\n         (my-with-connection session 5000\n                             (let [channel (ssh-sftp session)]\n                               (with-channel-connection channel\n                                                        (ssh session {:cmd (apply str \&quot;mkdir -p \&quot; destination)})\n                                                        (sftp channel {} :cd destination)\n                                                        (reset! progress (sftp-put channel input name)))))\n         (catch Exception e\n           (throw (ex-info (.getMessage e) {:progress @progress})))))\n      )))&quot; &quot;(defn upload-to-sftp\n  [host port input name destination username rsa-path]\n  (println \&quot;Starting...\&quot;)\n  (let [agent (ssh-agent {:use-system-ssh-agent false})]\n    (new-identity agent rsa-path)\n    (let [session (new-session agent host username port)]\n      (let [progress (atom 0)]\n        (try\n         (my-with-connection session 5000\n                             (let [channel (ssh-sftp session)]\n                               (with-channel-connection channel\n                                                        (ssh session {:cmd (apply str \&quot;mkdir -p \&quot; destination)})\n                                                        (sftp channel {} :cd destination)\n                                                        (reset! progress (sftp-put channel input name)))))\n         (catch Exception e\n           (throw (ex-info (.getMessage e) {:progress @progress})))))\n      )))&quot; &quot;(ns upload-test.core\n  (:gen-class)\n  (:use\n   upload-test.sftp-upload)\n  (:require\n    [clojure.java.io :as io]\n    [again.core :as again]\n    [upload-test.retries :refer :all]\n    [clojure.tools.cli :refer [cli]])\n  (:import org.apache.commons.io.input.BoundedInputStream))\n\n\n(def required-opts #{:host :port :file :destination :username :rsa-path})\n\n(defn missing-required?\n  \&quot;Returns true if opts is missing any of the required-opts\&quot;\n  [opts]\n  (not-every? opts required-opts))\n\n(defn file-size [filename]\n  (.length (io/file filename)))\n\n(defn check-progress\n  [f]\n  (let [up-progress (atom 0)]\n    (loop [retries 0]\n      (if (try (f)\n               (catch Exception e\n                 (if (&lt; 0 (- (get-in (ex-data e) [:progress]) @up-progress))\n                   (do (reset! up-progress (get-in (ex-data e) [:progress])) nil)\n                   (throw e))))\n        (prn \&quot;Success\&quot;)\n        (do (prn \&quot;Retry\&quot;) (recur (inc retries)))\n        )))\n  )\n\n(defn upload-async\n  [host port input name destination username rsa-path]\n  (future\n    (check-progress #(again/with-retries [100 100 100] (upload-to-sftp host port input name destination username rsa-path)))))\n\n(defn rounded-single-chunk-size\n  [file count]\n  (int (Math/ceil (/ (file-size file) count))))\n\n(defn chunks-list\n  [name start size]\n  {:name (apply str name \&quot;.part\&quot; (str start)) :start (* start size) :size size})\n\n(defn just-chunk\n  [file count]\n  (let [size (rounded-single-chunk-size file count)]\n    (map #(chunks-list file % size) (range count))))\n\n(defn chunk-and-send-file\n  [file count host port destination username rsa-path]\n  (-&gt;&gt;\n    (just-chunk file count)\n    (map\n      #(let [input (io/input-stream file)]\n        (.skip input (get-in % [:start]))\n        (let [bounded (BoundedInputStream. input (get-in % [:size]))]\n          (upload-async host port bounded (get-in % [:name]) destination username rsa-path))))\n    (map deref)\n    (doall)))\n\n(defn chunked_or_standard_upload [opts]\n  (if (:chunks opts)\n    (time\n      (chunk-and-send-file (:file opts) (Integer. (:chunks opts)) (:host opts) (Integer. (:port opts))\n                           (:destination opts) (:username opts) (:rsa-path opts)))\n    (time\n      (check-progress\n        #(again/with-retries\n          [100 100 100]\n          (upload-to-sftp\n            (:host opts) (Integer. (:port opts)) (:file opts)\n            (if (:name opts) (:name opts) (:file opts))\n            (:destination opts) (:username opts) (:rsa-path opts))))\n      )))\n\n(defn -main [&amp; args]\n  (let [[opts args banner] (cli args\n                                [\&quot;-h\&quot; \&quot;--help\&quot; \&quot;Print this help\&quot;\n                                 :default false :flag true]\n                                [\&quot;-c\&quot; \&quot;--chunks\&quot;]\n                                [\&quot;-f\&quot; \&quot;--file\&quot;]\n                                [\&quot;-n\&quot; \&quot;--name\&quot;]\n                                [\&quot;-d\&quot; \&quot;--destination\&quot;]\n                                [\&quot;-u\&quot; \&quot;--username\&quot;]\n                                [\&quot;-ip\&quot; \&quot;--host\&quot;]\n                                [\&quot;-p\&quot; \&quot;--port\&quot;]\n                                [\&quot;-rsa\&quot; \&quot;--rsa-path\&quot;])]\n    (if (or (:help opts)\n              (missing-required? opts))\n      (println banner)\n      (chunked_or_standard_upload opts)\n      )))\n\n\n(comment\n\n\n\n  (upload-async \&quot;192.168.1.105\&quot; 22 \&quot;x.txt\&quot; \&quot;lallaa\&quot; \&quot;Pulpit/takietam/tests\&quot; \&quot;kisiel\&quot; \&quot;/home/paveu/.ssh/id_rsa.test\&quot;)\n  (time (chunk-and-send-file \&quot;x.txt\&quot; 5 \&quot;192.168.1.105\&quot; 22 \&quot;Pulpit/takietam/tests\&quot; \&quot;kisiel\&quot; \&quot;/home/paveu/.ssh/id_rsa.test\&quot;))\n  (time (x \&quot;x.txt\&quot; 5 \&quot;192.168.1.105\&quot; 22 \&quot;Pulpit/takietam/tests\&quot; \&quot;kisiel\&quot; \&quot;/home/paveu/.ssh/id_rsa.test\&quot;))\n  (-main \&quot;-ip\&quot; \&quot;192.168.1.105\&quot; \&quot;-p\&quot; 22 \&quot;-f\&quot; \&quot;test1\&quot; \&quot;-d\&quot; \&quot;Pulpit/takietam/tests\&quot; \&quot;-u\&quot; \&quot;kisiel\&quot; \&quot;-rsa\&quot; \&quot;/home/paveu/.ssh/id_rsa.test\&quot;)\n  )&quot; &quot;(-main \&quot;-ip\&quot; \&quot;192.168.1.105\&quot; \&quot;-p\&quot; 22 \&quot;-f\&quot; \&quot;test1\&quot; \&quot;-d\&quot; \&quot;Pulpit/takietam/tests\&quot; \&quot;-u\&quot; \&quot;kisiel\&quot; \&quot;-rsa\&quot; \&quot;/home/paveu/.ssh/id_rsa.test\&quot;)&quot;], :remote []}}</component>
</project>